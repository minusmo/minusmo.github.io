---
layout: posts
title: About SOLID S & O
category: programming
tags: programmingPhilosophy OOP
---

## SOLID: 객체 지향 설계의 다섯 가지 원칙

### S: SRP(Single Responsibility Principle)
#### 한 클래스는 하나의 책임만 가져야 한다.

### O: OCP(Open/Closed Principle)
#### 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.  

### L: LSP(Liskov Substitution Principle)
#### 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.(계약에 의한 설계)

### I: ISP(Interface Segregation Principle)
#### "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."  

### D: DIP(Dependency Inversion Principle)
#### 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다. 

[SOLID in Wikipedia](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))


### SRP  
객체 지향 프로그래밍에서 **단일 책임 원칙(single responsibility principle)**
이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.  

로버트 마틴에 의하면, **책임**은 __*변경하려는 이유*__ 이며, 어떤 클래스나 모듈은 변경하려는 단 하나의 이유만을 가져야한다.  

예를 들어, 보고서를 편집하고 출력하는 모듈을 생각해보자.  
이 모듈은 두 가지 이유로 변경될 수 있다.  
첫 번째로 보고서의 내용 때문에 변경될 수 있다.  
두 번째로 보고서의 형식 때문에 변결될 수 있다.  

이 두 가지 변경은 하나는 실질적이고 다른 하나는 꾸미기 위한 매우 다른 원인에 기인한다.  

단일 책임 원칙에 의하면 이 문제의 두 측면이 실제로 분리된 두 책임 때문이며, 따라서 분리된 클래스나 모듈로 나누어야 한다.  
다른 시기에 다른 이유로 변경되어야하는 두 가지를 묶는 것은 나쁜 설계일 수 있다. 

한 클래스를 한 관심사에 집중하도록 유지하는 것이 중요한 이유는,  
이것이 클래스를 더욱 튼튼하게 만들기 때문이다. 앞서 든 예를 계속 살펴보면, 편집과정에 변경이 일어나면 같은 클래스의 일부로 있는 출력 코드가 망가질 위험이 대단히 높다.  
[SRP in Wikipedia](https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%B1%85%EC%9E%84_%EC%9B%90%EC%B9%99)

### OCP
**개방-폐쇄 원칙(open-closed principle)** 은 소프트웨어 개체(클래스, 모듈, 함수 등등)는 __*확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다*__ 는 프로그래밍 원칙이다.  

소프트웨어 개발에 이용된 많은 모듈 중에 하나에 수정을 가할 때, 그 모듈을 이용하는 다른 모듈을 줄줄이 고쳐야 한다면, 이와 같은 프로그램은 수정하기 어렵다. 개방-폐쇄 원칙은 시스템의 구조를 올바르게 재조직(리팩토링)하여 나중에 이와 같은 유형의 변경이 더 이상의 수정을 유발하지 않도록 하는 것이다.  
개방-폐쇄 원칙이 잘 적용되면, 기능을 추가하거나 변경해야 할 때, 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.  

#### 개방-폐쇄 원칙의 두 가지 속성
**1. 확장에 대해 열려있다.**  
이것은 모듈의 동작을 확장할 수 있다는 의미이다.  
애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.  

**2. 수정에 대해 닫혀있다.**  
모듈의 소스코드나 바이너리 코드를 수정하지 않아도, 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 간으한 바이너리 형태나 링크 가능한 라이브러리(윈도우의 DLL이나 자바의 .jar같은)를 건드릴 필요가 없다.  

#### 추상화를 통한 개방-폐쇄 원칙  
객체 지향 프로그래밍 언어(JAVA, C++)에서는 고정되기는 해도 제한되지는 않은, 가능한 동작의 묶음을 표현하는 추상화가 가능하다. 모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에, 수정에 대해 닫혀 있을 수 있고, 반대로 추상화의 새 파생 클래스를 만드는 것을 통해 확장도 가능하다. 따라서 추상화는 개방-폐쇄 원칙의 핵심 요소이다.  

#### 개방-폐쇄 원칙과 객체 지향 언어의 관계  
개방-폐쇄 원칙은 객체 지향 프로그래밍의 핵심 원칙이라고 할 수 있다. 개방-폐쇄 원칙을 따르지 않는다고 해서 객체 지향 언어의 구현이 불가능한 것은 아니지만, 이 원칙을 무시하고 프로그래밍을 한다면, 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 결코 얻을 수 없다. 따라서 객체 지향 프로그래밍 언어에서 개방-폐쇄 원칙은 반드시 지켜야할 기본적인 원칙이다.  
[OCP in Wikipedia](https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99)