---
layout: posts
title: About Clean Code Ch7
category: programming
tags: programmingPhilosolphy exceptionHandling OOP
---

# Clean Code에 대하여

**_in Clean Code by Robert C. Martin_**

## Ch7 오류 처리

오류 처리는 중요하다. 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

### 오류 코드보다 예외를 사용하라

오류 코드를 사용하면 호출자 코드가 복잡해진다. 함수를 호출한 즉시 오류를 확인해야하기 때문이다.
그래서 오류가 발생하면 **예외를 던지는 것** 이 낫다. 그러면 호출자 코드가 더 깔끔해진다. 논리가 오류 처리 코드와
뒤섞이지 않기 때문이다.

_기능을 수행하는 알고리즘_ 과 _오류를 처리하는 알고리즘_ 을 분리하라.

### Try-Catch-Finally 문부터 작성하라

_try-catch-finally_ 문에서 _try_ 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후
_catch_ 블록으로 넘어갈 수 있다.  
예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하자. 그러면 try 블록에서 무슨 일이 생기든지
호줄자가 기대하는 상태를 정의하기 쉬워진다.

try-catch 구조로 범위를 정의한 후, _TDD_ 를 사용해 필요한 나머지 논리를 추가한다.
먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다.

### 미확인 예외를 사용하라

확인된 예외(checked exception)는 기존에는 옳은 방법이라고 여겨졌으나, 이제는
미확인 예외(unchecked exception)으로도 충분히 안정적인 소프트웨어를 구현할 수 있다는
사실이 분명해졌다.

확인된 오류가 치르는 비용 중의 하나는 **_OCP 위반_** 이다. 만약 확인된 예외에 변경이 일어났다면,
그 예외를 던지는 모듈과 직접적인 상관이 없는 다른 모듈까지 모두 수정해야하는 일이 벌어질 수도 있다.

### 예외에 의미를 제공하라

예외를 던질 때는 전/후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다.
오류 메시지에 정보를 담아 예외와 함께 던진다. _실패한 연산 이름_ 과 _실패 유형_ 도 언급한다. 애플리케이션이
로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

### 호출자를 고려해 예외 클래스를 정의하라

오류를 분류하는 방법은 수없이 많다. 하지만, 애플리케이션에서 오류를 정의할 때
프로그래머에게 가장 중요한 관심사는 **_오류를 잡아내는 방법_** 이 되어야 한다.
외부 API를 사용할 때는 _감싸기 기법_ 이 유용하다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에
의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈아타도 비용이 적다. 또한 감싸기 클래스에서 외부 API를
호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.

마지막 장점으로 _감싸기 기법_ 을 사용하면 특정 업체가 API를 설계한 방식에 발목잡히지 않는다.
프로그램이 사용하기 편리한 API를 정의하면 그만이다.

흔히 예외 클래스가 하나만 있어도 충분한 코드가 많다. 예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 그렇다.
한 예외는 잡아내고 다른 예외는 무시해도 괜찮은 경우라면 여러 예외 클래스를 사용한다.

### 정상 흐름을 정의하라

위의 패턴을 잘 따라간다면 좋은 코드가 나올 확률이 높다. 하지만 때로는 예외 처리로 인한 중단이 적합하지 않은 때도 있다.  
**_특수 사례 패턴_** 의 경우에, 클래스를 만들거나 객체를 조작해 특수 사레를 처리한다. 그러면 클라이언트 코드가
예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하기 때문이다.

### null을 반환하지 마라

null을 반환하는 습관은 우리가 흔하게 저지르는 오류를 유발하는 행위이다.
null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.
null을 하나라도 놓치는 경우에는 애플리케이션이 통제 불능에 빠질지도 모른다.

메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 _예외를 던지거나_ _특수 사례 객체_ 를 반환한다.
사용하려는 외부 API가 null을 반환한다면 _감싸기 메서드_ 를 구현해 예외를 던지거나 _특수 사례 객체_ 를
반환하는 방식을 고려한다. 많은 경우에 특수 사례 객체가 손쉬운 해결책이다.

### null을 전달하지 마라

메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.
정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.

대다수 프로그래밍 언어들은 호출자가 실수로 넘기는 _null_ 을 적절히 처리하는 방법이 없다.
그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 즉, 인수로 null이 넘어오면
코드에 문제가 있다는 말이다. 이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다.

## 결론

깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다.
오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.
오류 처리를 프로그램 논리와 분리하면 _독립적인 추론_ 이 가능해지며 _코드 유지보수성_ 도 크게 높아진다.
